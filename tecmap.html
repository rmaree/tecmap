<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TECmap : Carte des transports en commun (TEC) en temps r√©el</title>

    <!-- Leaflet CSS & JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css">
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

    <!-- load local transit data: stops and trips -->
    <script src="data/stops.js"></script>  <!-- loads stopsData  -->
    <!-- <script src="data/stop_times.js"></script> --> <!-- loads horairesData should organize data by routeId or by day or ... ?--> 

    <!-- Style FontAwesome pour les ic√¥nes -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

    
    <style>
     #map { height: 98vh; }

     .custom-user-marker {
	 font-size: 44px;
	 color: blue;
	 text-shadow: 1px 1px 2px white;
     }
     
     /* Classes dynamiques pour changer la couleur des ic√¥nes */
     .bus-icon-black { color: black; }
     .bus-icon-green { color: green; }
     .bus-icon-orange { color: orange; }
     .bus-icon-red { color: red; }
     .bus-icon-grey { color: grey; }
     .bus-icon {
	 font-size: 24px;
	 text-shadow: 
	     -2px -2px 2px white, 
	     2px -2px 2px white, 
	     -2px 2px 2px white, 
	     2px 2px 2px white;
	 border-radius: 50%;
	 background: white;
	 padding: 5px;
     }
     .bus-marker {
	 position: relative;
	 width: 40px;
	 height: 40px;
	 background: white;
	 border-radius: 50%;
	 display: flex;
	 align-items: center;
	 justify-content: center;
	 box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
     }

     .bus-marker i {
	 font-size: 18px;
	 color: black;
     }

     .bus-number {
	 position: absolute;
	 bottom: -15px;
	 left: 50%;
	 transform: translateX(-50%);
	 font-size: 12px;
	 font-weight: bold;
	 background: white;
	 padding: 2px 5px;
	 border-radius: 5px;
	 box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
     }

     button {
	 background: none;
	 border: none;
	 font-size: 14px;
	 cursor: pointer;
     }

     .leaflet-popup-content {
	 min-width: 250px; 
	 max-width: 400px; 
	 white-space: normal; 
     }
     
     
    </style>
</head>
<body>

  <!-- Filter area -->
  <div id="filter-container" style="position: absolute; top: 10px; left: 50px; background: white; padding: 5px; z-index: 1000;">
    <div style="display: flex; align-items: center; gap: 5px;">
	  <input type="text" id="busFilter" placeholder="Filtrer par ligne de bus" oninput="fetchRealTimeBusData()">
	  <span><a href="https://busmaps.com/en/feedinfo/belgium/TEC-Transit/tec-transit/routes">?</a></span>
	  <button onclick="clearFilter()">‚ùå</button>
      </div>
      <p style="margin: 0;">Nombre de bus sur la carte: <span id="busCount">0</span></p>
  </div>
  
  <div id="map"></div>

  <script>
   //Chargement donn√©es arr√™ts (local)
   // the real-time API end-point
   const RT_API_URL = ''; // the real-time API end-point
   const RT_REFRESH_RATE = 10000; // refresh real-time traffic data every 10 seconds
   // the tile server API key
   const TILE_API_KEY = ''; // the tile server API key
   let busMarkers = {};  // Marqueurs des bus

   
   // ---------------------------------------------------------------------------------------------
   // Initialisation de la carte, coordonnees par defaut ou demande de geolocalisation
   const defaultCoords = [50.63, 5.56];
   const map = L.map('map').setView(defaultCoords, 16);  
   // V√©rifier si la g√©olocalisation est disponible
   if (navigator.geolocation) {
       navigator.geolocation.getCurrentPosition(
	   (position) => {
	       const userCoords = [position.coords.latitude, position.coords.longitude];
	       map.setView(userCoords, 16); // Centrer sur la position de l'utilisateur
	       
	       // Ajouter un marqueur pour la position de l'utilisateur
	       L.marker(userCoords, {
		   icon: L.divIcon({
		       className: 'custom-user-marker',
		       html: '<i class="fas fa-map-marker-alt"></i>',
		       iconSize: [40, 40],
		       iconAnchor: [20, 20]
		   })
	       }).addTo(map)
		.bindPopup("Vous √™tes ici").openPopup();
	   },
	   () => {
	       console.warn("G√©olocalisation refus√©e ou indisponible. Utilisation des coordonn√©es par d√©faut.");
	   }
       );
   } else {
       console.warn("G√©olocalisation non support√©e par le navigateur.");
   }
   // tileLayer from thunderforest can be used using an apikey, replace XXXXXXXXX by yours
   if (TILE_API_KEY) {
       const tileLayer = L.tileLayer('https://tile.thunderforest.com/transport/{z}/{x}/{y}.png?apikey='+TILE_API_KEY, {
     	   attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, tiles &copy; <a href="https://www.thunderforest.com/maps/transport/">Thunderforest</a>',
   	   maxZoom: 22
       });
       tileLayer.addTo(map);
   }
   else {
       //default OSM tiles:
       L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
	   attribution: '&copy; OpenStreetMap contributors'
       }).addTo(map);
   }


   // ---------------------------------------------------------------------------------------------
   // Definitions de fonctions utilitaires
   // Fonction pour charger dynamiquement le fichier des horaires en fonction du jour
   function loadScheduleFile() {
       const dayOfWeek = new Date().getDay(); 
       let scriptFile = "data/stop_times-SEM.js"; // Par d√©faut, horaires pour les jours de la semaine

       if (dayOfWeek === 0) { // Dimanche
           scriptFile = "data/stop_times-DIM.js";
       } else if (dayOfWeek === 6) { // Samedi
           scriptFile = "data/stop_times-SAM.js";
       } else if (dayOfWeek === 3) { // Mercredi
           scriptFile = "data/stop_times-MER.js";
       }

       // Cr√©er et ins√©rer dynamiquement un script
       const script = document.createElement("script");
       script.src = scriptFile;
       script.onload = () => console.log(`Horaires th√©oriques charg√©s depuis ${scriptFile}`);
       script.onerror = () => console.error(`Erreur de chargement du fichier ${scriptFile}`);

       document.head.appendChild(script);
   }

   

   // Fonction pour nettoyer le filtre
   function clearFilter() {
       document.getElementById('busFilter').value = '';
       fetchRealTimeBusData(); // Recupere data apres la suppression du filtre
   }
   
   // Calcul du nombre de minutes depuis le d√©marrage du bus
   // not used anymore
   function getTimeSinceStart(startTime) {
       const now = new Date(); // Heure actuelle
       const currentDate = now.toISOString().split('T')[0];
       const fullStartTime = `${currentDate}T${startTime}`;
       const startDate = new Date(fullStartTime); // Convertir startTime en objet Date
       const differenceInMillis = now - startDate; // Diff√©rence en millisecondes
       const differenceInMinutes = Math.floor(differenceInMillis / 60000); // Convertir en minutes
       return differenceInMinutes;
   }


   // Recupere le nom lisible d'un arret
   function getStopName(stopId, stopsMap) {
       if (stopId) {
	   return stopsMap[stopId] || "Arr√™t inconnu";
       }
   }

   
   // D√©termine la couleur de l'ic√¥ne du bus en fonction de la vitesse
   function getBusSpeedColor(speed) {
       if (speed === null) return "grey";
       else if (speed < 10) return "black";
       else if (speed >= 10 && speed <= 50) return "green";
       else if (speed > 50 && speed <= 70) return "orange";
       else return "red";
   }

   // D√©termine la couleur de l'ic√¥ne du bus en fonction de son retard
   function getBusDelayColor(delay) {
       if (delay > 0 && delay < 5) return "orange"; 
       else if (delay >= 5) return "red";
       else return "green";
   }

   // Convertir timestamp UNIX en temps lisible
   function timestampToTime(timestamp) {
       const date = new Date(timestamp * 1000); // Convertir en millisecondes
       const hours = date.getHours().toString().padStart(2, '0');
       const minutes = date.getMinutes().toString().padStart(2, '0');
       const seconds = date.getSeconds().toString().padStart(2, '0');
       return `${hours}:${minutes}:${seconds}`;
   }

   // Convertir temps lisible en timestamp UNIX
   function timeToUnixTimestamp(timeStr, referenceDate = new Date()) {
       const [hours, minutes] = timeStr.split(":").map(Number);  //time is formatted HH:MM
       // Copier la date de r√©f√©rence Unix et mettre l'heure indiqu√©e
       const date = new Date(referenceDate);
       date.setHours(hours, minutes, 0, 0);
       // Retourner le timestamp Unix en secondes
       return Math.floor(date.getTime() / 1000);
   }

   
   // Calcule le retard d'un bus etant donnee le trajet theorique (schedule), le prochain arr√™t, et le timestamp temps reel
   function estimateDelay(schedule,currentStopSequence,timestamp) {
       //comparer l'heure qu'il est avec l'heure √† laquelle il est suppos√© arriver au prochain arret, si heure courante superieure = retard
       if (schedule[currentStopSequence-1])
	   return Math.round((timestamp - timeToUnixTimestamp(schedule[currentStopSequence-1].a))/60);
   }

   // Retourne le nom lisible du premier arr√™t d'un trajet
   function getStartPoint(tripId) {
       const schedule = horairesData[tripId]; // busSchedules doit contenir les donn√©es du fichier
       if (schedule)
	   return getStopName(schedule[0].s,stopsData)  //s = stopId
       else return " "
   }

   // Retourne le nom lisible du terminus d'un trajet
   function getEndPoint(tripId) {
       const schedule = horairesData[tripId]; // busSchedules doit contenir les donn√©es du fichier
       if (schedule)
	   return getStopName(schedule[(schedule.length)-1].s,stopsData)  // s = stopId
       else return " "

   }

   // Genere l'HTML de l'horaire de ce trip avec affichage du retard
   function showSchedule(tripId, startTime, currentStopSequence, nextStopId, timestamp, delay, element) {
       const scheduleDiv = document.getElementById(`schedule-${tripId}`);
       if (scheduleDiv.innerHTML) {
           scheduleDiv.innerHTML = ""; // Masque l'horaire si d√©j√† affich√©
           element.closest(".leaflet-popup").style.width = ""; // R√©initialiser la largeur
           return;
       }
       // Simuler un chargement (optionnel)
       scheduleDiv.innerHTML = "Chargement...";

       // R√©cup√©rer les horaires de ce trajet a partir des donnees horaires theoriques
       const schedule = horairesData[tripId];  // variable definie dans le .js charg√©
       
       if (!schedule) {
           scheduleDiv.innerHTML = "<span>Aucun horaire trouv√©.</span>";
           return;
       }

       const stringdelay = delay > 0 ? '(+'+delay+')' : '';
       // Construire l'affichage des horaires
       let scheduleHtml = "<ul>";
       //scheduleHtml += `Delta estim√©: ${estimate `;
       schedule.forEach(entry => {
	   const stopName = getStopName(entry.s,stopsData);
	   const isNextStop = entry.s === nextStopId;
	   // entry.a = arrival_time
	   if (isNextStop)
	       scheduleHtml += `<li ${isNextStop ? 'style="font-weight: bold; "' : ''}>
         ${entry.a.slice(0, 5)} <span style="color: red;"> ${stringdelay} </span> - ${stopName} 
         </li>`;
	   else
	       scheduleHtml += `<li ${isNextStop ? 'style="font-weight: bold; "' : ''}>
         ${entry.a.slice(0, 5)} - ${stopName} 
         </li>`;		 
	   
       });
       scheduleHtml += "</ul>";
       
       scheduleDiv.innerHTML = scheduleHtml;

       // ajuster largeur popup
       const popup = element.closest(".leaflet-popup");
       if (popup) {
           popup.style.width = Math.min(500, scheduleDiv.scrollWidth + 50) + "px"; 
       }

   }
   
   

   // ---------------------------------------------------------------------------------------------
   // Fonction principale pour r√©cup√©rer les donnees temps reel et afficher les marqueurs des bus sur la carte
   async function fetchRealTimeBusData() {
       try {
	   // Uses external API to get real-time json data
	   const response = await fetch(RT_API_URL); 
           const data = await response.json();

	   // R√©cup√®re la valeur du filtre de ligne entr√© par l'utilisateur.ice
	   let filterValues = document.getElementById('busFilter').value.split(" ").map(num => num.trim()); // Convertit en tableau

	   // V√©rifier et initialiser busMarkers correctement
	   if (!Array.isArray(busMarkers)) {
	       busMarkers = [];
	   }
	   
	   // Supprimer les anciens marqueurs
	   if (busMarkers) {
	       busMarkers.forEach(marker => map.removeLayer(marker));
	       busMarkers = [];
	   }
	   
           data.markers.forEach(bus => {
               const { vehicleId, latitude, longitude, speed, trip, stopId, currentStopSequence, timestamp } = bus;

	       // Appliquer le filtre (si non vide)
	       if (filterValues.length > 0 && filterValues[0] != '' && !filterValues.includes(trip.route_short_name.toString())) return;
	       
	       const nextStopName = getStopName(bus.stopId,stopsData);
	       // not used anymore
	       //const timeSinceStart = getTimeSinceStart(bus.trip.startTime);
	       const startPoint = getStartPoint(bus.trip.tripId);
	       const endPoint = getEndPoint(bus.trip.tripId);

	       //Bus icon color can be either based on delay, or on bus speed.
	       const schedule = horairesData[bus.trip.tripId];
	       const delay = schedule ? estimateDelay(schedule,bus.currentStopSequence,bus.timestamp) : 0;
	       const busColor = getBusDelayColor(delay);
	       //const busColor = getBusSpeedColor(speed);

	       // Contenu du popup (pourrait n'√™tre cr√©√© qu'onclick)
	       //<b>Ligne ${trip.route_short_name}</b> - ${trip.route_long_name} <br>
	       //üèÅ D√©marrage: ${bus.trip.startTime} (il y a ${timeSinceStart} minutes)<br>
               const popupContent = `
         <b>Ligne ${trip.route_short_name}</b> ${trip.route_long_name} <br>
         Direction: ${startPoint} <i class="fas fa-arrow-right"></i> ${endPoint} <br>
         <!-- üöå Bus ID: ${vehicleId} <br> //-->
         <i class="fas fa-map-marker-alt"></i> Position: ${latitude.toFixed(5)}, ${longitude.toFixed(5)} <br>
         <i class="fas fa-tachometer-alt"></i> Vitesse: ${speed ? speed + " km/h" : "N/A"} <br>
         <i class="fas fa-bus"></i> Prochain arr√™t: ${nextStopName} ${delay>0 ? '<span style="color:red;">+'+delay+'</span>': ""}<br>
         <a href="#" onclick="showSchedule('${bus.trip.tripId}','${bus.trip.startTime}', '${bus.currentStopSequence}', '${bus.stopId}', '${bus.timestamp}', '${delay}', this)">Voir l'horaire</a>
                        <div id="schedule-${bus.trip.tripId}"></div>
               `;

	       // D√©finition de l'ic√¥ne avec couleur dynamique en fonction de la vitesse
	       const busIcon = L.divIcon({
		   html: `
                       <div class="bus-marker" style="border: 3px solid ${busColor};">
                           <i class="fas fa-bus" style="color: ${busColor};"></i>
                           <span class="bus-number">${bus.trip.route_short_name}</span>
                       </div>
                   `,
		   className: 'custom-bus-icon',
		   iconSize: [40, 40],
		   iconAnchor: [20, 20]
	       });


               if (busMarkers[vehicleId]) {
                   // Mise √† jour du marqueur existant // not used anymore since we delete busmarkers
                   busMarkers[vehicleId].setLatLng([latitude, longitude])
					.setPopupContent(popupContent)
					.setIcon(busIcon);
               } else {
                   // Ajout d'un nouveau marqueur
                   busMarkers[vehicleId] = L.marker([latitude, longitude], { icon: busIcon}).addTo(map)
		                            .bindTooltip(`<i class="fas fa-arrow-right"></i> ${endPoint}`, { permanent: false, direction: "top" })
					    .bindPopup(popupContent);
               }

           });
	   //update the number of visible bus in map view
	   let bounds = map.getBounds();
	   let visibleBuses = busMarkers.filter(marker => bounds.contains(marker.getLatLng()));
	   document.getElementById('busCount').textContent = visibleBuses.length;
       } catch (error) {
           console.error("Erreur lors du chargement des donn√©es distantes:", error);
       }
   }

   //Chargement des horaires theoriques
   loadScheduleFile();


   // Rafra√Æchir toutes les 6 secondes
   fetchRealTimeBusData();
   setInterval(fetchRealTimeBusData, RT_REFRESH_RATE);

  </script>
</body>
</html>
